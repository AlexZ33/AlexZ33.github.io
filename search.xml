<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2017读书计划]]></title>
      <url>%2F2016%2F12%2F29%2F2017%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[2017读书计划 我这人比较懒散，兴之所至往往能把一本书一口气看完，或言“毎归私第,阖户启箧取书,读之竟日”。而大多数时候，都是拿起书来提起了兴趣便读一读，失却了兴致就放在一边，所以留下很多“半读品”。 时至今日，再也不想东一榔头西一棒子，捡起什么就看什么。所以又起了建构、丰满自身识见体系的抱负。 于是，便有了这篇2017年读书计划。其实，这不仅仅是一个书单列表，也是一份学习计划。 细心的朋友会发现，它主要涉及三个方面 ： 历史文学阅读+编程知识+经济财务。历史类将以两宋和伊斯兰文明和美国史为主。编程以前端为主，兼有建站、小程序到Linux，看学习进度。全栈将是一个长期目标经济财务类主要是经济理论和服务于cpa考试的财务知识。 有兴趣的书友可以一起参与。 文末可加读书群。 以下所列书目有不少以前已经看过或者开了篇没有看完。 ①已读 下面标有此类的将视时间温故 ②未读 ③读未尽 历史 历史类书籍一直是我的最爱，“一切历史都是当代史。” 这些历史材料就像今日和未来的镜子，镜人，镜心。 易中天老师在《文明的意志与中华的位置》一书中言： 只有中华，伊斯兰，和西方现代才代表了三代文明。同时最具世界性。 所以本年度将以此三者作为读史的重点。 《人类群星闪耀时》① 《你一定喜爱的欧洲极简史》① 《易中天中华史》① 截止2017年1月9日出版的已读 《赫逊河畔谈中国历史》① 《全球通史》① 这本书作为读史的框架不错 《丝绸之路》 《宋代政治史》③ 《剑桥中国 辽西夏金元史》① 《剑桥伊朗史》(Cambridge History of Iran) ③ 《草原帝国》(The Empire of the Steppes)中文版，作者：（法）格鲁塞(Grousset) ③ 《阿拉伯通史》中文版，作者：（美）希提(Philip Khuri Hitti) 《 文明的冲突与世界秩序的重建 》 （美） 赛缪尔.亨廷顿 《 重回耶路撒冷 - 犹太人的三千年 》 （中）张力升 《土耳其通史》① 《埃及通史》① 《费城风云：美国宪法的诞生及启示》 《1491》 《1493》 《殖民地》 《美国宪法的经济观》 《万历十五年》① 《明朝那些事儿》① 《明史讲义》 互联网&amp;编程 《JavaScript设计模式与开发实践》 《JavaScript高级程序设计》 《你不知道的JavaScript》 《jQuery权威指南》 《微信小程序入门指南》 编程相关只是近期想看的 更多内容请留意公众号的技术文章和博客（http://jxdxsw.com） 《数据之巅》① 《大数据时代》① KK三部曲 《失控》① 《科技想要什么》③ 《必然》③ 经济&amp;财务 《魔鬼经济学》 《历代经济变革》① 《理念的力量》① 《市场的逻辑》① 《理解公司》① 《国富论》 （《资本论》这本看情况吧） 《激荡30年》① 《哈耶克传》① 《变革中国：市场经济的中国之路》③ 《让数字说话：审计就这么简单》③ 《一本书读懂财报》③ cpa相关以 镜心的小树屋 推送的笔记为准 文学&amp;写作&amp;相关 《千面英雄》① 《故事：材质、结构、风格和银幕剧作的原理》 《故事策略：电影剧本必备的23个故事段落》 《小说写作教程：虚构文学》 《作家之旅：源自神话的写作要义》 《写作这回事：创作生涯回忆录》 史蒂芬金 《纸牌屋》 《无声告白》 《虫：2.5次世界大战》③ 《马克吐温小说全集》③ 《迟子建散文》 《三体》① 《皮囊》蔡崇达 ① 注 : 镜心书社 『读书给你听』 系列会读到 《战争与和平》 《雾都孤儿》 《培根随笔》 《毛姆读书笔记》① 《毛姆短篇小说精选集》③ 《京华烟云》 《一个陌生女人的来信》① 《査令十字街84号》 《文学回忆录 》③ 《纪伯伦散文集》 《世界最好的杂文》 《变形记》① 《三个火枪手》 《朱自清散文集》③ 《了不起的盖茨比》① 《东野圭吾全集》 注： 书友可以挑选着看 真的很多 推荐《彷徨之刃》《嫌疑人x的献身》《虚无的十字架》 《24个比利》 《东方快车谋杀案》 《无人生还》 《大江东去》 《巨人的陨落》 思想&amp;社会&amp;哲学 《顾准文集》③ 《胡适的北大哲学课（四卷）》 《西方哲学史》伯特兰罗素① 《论美国的民主》① 《旧制度与大革命》① 《君主论论李维》① 《社会契约论》① 《中国哲学简史》冯友兰 《宽容》房龙 《公正》迈克尔?桑德尔 有公开课视频，书友可以去找下 《反对完美》 诗集 《随园诗话》 《人间词话》① 《万叶集》① 注：日本俳句 中译版本众多，不记得以前买的是哪本了，有时间回味下。《言叶之庭》里面经典那句出自于此 杂 《我可以咬你一口吗》 《从0到1》① 《异类》① 《美食家》 《雅舍谈吃》 《如何阅读一本书》① 《自私的基因》 《谈美书简》 《听音乐》罗杰·凯密恩（Roger Kamien） 《认识电影》[美] 路易斯·贾内梯 / [瑞典] 英格玛·伯格曼 [日] 黑泽明 等供图 《七堂极简物理课》 《时间简史》 文末引用狄更斯说过的话： “这是最好的时代，这是最坏的时代；这是智慧的时代，这是愚蠢的时代；这是信仰的时期，这是怀疑的时期；这是光明的季节，这是黑暗的季节；这是希望之春，这是失望之冬；人们面前有着各样事物，人们面前一无所有；人们正在直登天堂，人们正在直下地狱。” 诸君，有长风起于青萍之末，你可曾听到？ 如有疏漏或删减我会在留言中补上，以实际阅读为准 1.10《虫：2.5次世界大战》 已读 1.14 《易中天中华史：国家》 已读 1.16 《变革中国：市场经济的中国之路》 已读 1.21 《宋史十讲》 已读 1.23 《我的剑桥历史笔记》已读 1.27 《如果这就是宋史7》 已读 1.30 《如果这就是宋史6》 已读 2.2 《虫：虫子的世界》 已读 2.5 《如果这就是宋史5》 已读 2.10 《培根随笔》 已读 建议反复阅读 2.13 《你一定爱读的法国极简史》 这本书写的很差 条理不清，语句颠三倒四 看了一半弃了 转战 《法国通史》 吕一民 2.15 《神探伽利略》东野圭吾 已读 2.17 《最璀璨的银河》 刘慈欣经典作品集 已读 有一两篇不太喜欢，大部分比较有意思。推荐 2.21 《法国通史》 吕一民已读 详实有条例，但众所周知的原因，一写到左派或者罢工革命之类的就不那么客观。 2.22 《未来边缘》已读 5个科幻小故事。大刘的脑洞确实大，简直科幻沙漠里的一股清泉。对比同侪的科幻作者的作品就能发现。 2.24 《如果这就是宋史4》 已读 主要是仁宗期间的事 2.25《追杀k星人》 王晋康 10篇科幻短篇 作者的脑洞虽不及大刘 、故事却更为完整，充满人性的冲突与讨论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何评价嵇康？]]></title>
      <url>%2F2016%2F09%2F18%2F%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E5%B5%87%E5%BA%B7%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[如何评价嵇康？ 本文系博主回答知乎同名问题所写文章，谢绝转载。知乎问题链接 这个问题太大了，大到可以写一篇论文了。不过我觉得评价文人何必争第一第二。（虽然我认为嵇康强点）所谓“文无第一，武无第二”。文学哲学上的造诣你很难用量化对比的方式进行评析，只能从审美情趣的角度来。“嵇康师心以遣论，阮籍使气以命诗”，这二人一个文章写的好学问高，一个诗词作的好格调高。很难说是孰优孰劣。而且我们在讨论三国两晋南北朝时期的人物时候，并不能和当时的历史割裂开来，他们是一种时代群像，有着特定的历史含义和文化意象。在这一时期，几乎每一项人文学科我们都能找到开拓性的巨匠，乱世出英雄，乱世也出哲人思想家和文学巨匠。曹操、曹丕、曹植、诸葛亮、“竹林七贤”、“建安风骨”几乎每一位都开一代之文宗。不过最能代表三国两晋南北朝的时代文化特征的，并不是曹操诸葛亮他们，而是一群被称为“魏晋文士”的人。曹操诸葛亮他们毕竟是残酷时代的制造者和参与者，而真正的文人却是放荡形骸、纵情自然，因此也称为了主流价值体系的叛离者。真正的魏晋风度。 就是他们这一群主流价值体系的叛离者为我们描绘出了一副丧乱年代的历史群像。在这样一个混乱年代的大舞台，一大群政治家、军事家、雄辩家、阴谋家、文化精英活跃其上。贵族有贵族的派头，布衣有布衣的风采。美男子受崇尚，丑男子也有充分的表演机会。七贤中的刘伶生得矮小丑陋，可他能量不小，一辈子花样百出。丑人能像他，也能活得魅力四射。在此时代，又是一个充满时尚的年代，而时尚的倡导者就是这些魏晋文士。时尚随处可见。穿漂亮衣裳是时尚，扪虱而谈也是时尚；平民走路像军人，时尚；贵族躺在路边睡大觉，同样时尚……这些时尚中，更是产生了两个特殊艺术人格的意象，这两个意象非常奇特，难以解释，但却贯通古今。第一个意象是阮籍的哭。他经常坐着牛车往前走，到哪里也不知道。当时的路，四通八达的不多。走着走着就走不通了，于是牛车停下来，他就嚎啕大哭，然后让车子调转头，走另一条里，等再走到了尽头，又嚎啕大哭。这是荒野中的哭号，没有任何人能看见，他是在哭给自己听。他这种哭号在现在人看来很是后现代主义。 中古的文人们不是特别认同，王勃在《滕王阁序》中言：孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！他对此噗之以鼻，以为不值得效仿。然而我们真的能这么理解吗，显然不是的，之前我们说过，这是一种特殊艺术人格的神秘部位。余秋雨在答北大学生问时候是这么解释的 他这种哭，既不是针对古人，也不是针对世道，也不针对自己。那是一种宏大的哭，具有整体象征意义的哭，却又说不清象征什么。我看中的&gt; 正是这点。好像是在哭人生途穷、长天冷漠。更重要的是，这种苦又是与一般意义上的悲伤不同，他一次次地重复寻找这种哭的机会，一次次&gt; 寻找走不通的路。他追求这种体验，而且是一种隐秘的、纯个人的体验。这是极为超越的大人格、大行为，足以凌驾古今中外。 常人无法理解阮籍，就跟钥匙和锁不配套一样。他这把孤独的锁，找不到钥匙，一如“高尚流水”，得真正碰到知音。第二个意象是“啸”。（待续 先把文章骨架写出来 时间来不及）总之，那年代挺丰富的，也挺有趣的，城里的各色人等，各成姿态。中国的历史长河，这样的景观可不多。竹林七贤，是魏晋风度的一个缩影。而我们的嵇康，走在最前面。嵇康比阮籍更厉害之处在于，他是大学问家，对道家和易经的研究很深。。。。。待续 身贵名贱。荣辱何在。贵得肆志。纵心无悔。人生寿促。天地长久。百年之期。孰云其寿。 旷然无忧患，宁然无思虑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[李清照有多伟大]]></title>
      <url>%2F2016%2F08%2F26%2F%E6%9D%8E%E6%B8%85%E7%85%A7%E6%9C%89%E5%A4%9A%E4%BC%9F%E5%A4%A7%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[李清照有多伟大 本文系博主回答知乎同名问题所写文章，谢绝转载。知乎问题链接 “秀影茕立，凝眉终古” 这是我脑海里易安居士的形象。 我不知道她算不算的得上伟大，但我深深的被她所吸引。吸引我的， 是她喷珠漱玉的词章；是她澄明清透的心性；是她凝眉轻蹙的倩影； 千古风流八咏楼，江山留与后人愁。水通南国三千里，气压江城十四州。 强敌临境，国脉衰颓下的八咏楼，她登临其上，再难生起“遥吟俯畅，逸兴遄飞”的博雅风华，填塞胸臆的唯有漫天匝地，茫茫无际的国恨家愁。时光穿透近九百年，我仿佛看到了这位已过知命之年的女词仙，她面带倦容，风尘仆仆，两弯凝眉似蹙非蹙，一腔悲抑残形消骨。生怕离别苦，多少事、欲说还休。新来瘦，非干病酒，不是悲秋她少年繁华，中经丧乱，晚景凄苦。一语谓之“忧患得失，何其多也”。其诗其词其人，非一个“愁”字所能概括的，可以说极为繁杂丰富，情思深远。 沉醉不知归路，兴尽晚回舟，误入藕花深处 这是她少女年华的娇憨 小院闲窗春已深。重帘未卷影沉沉。倚楼无语理瑶琴。远岫出云催薄暮，细风吹雨弄轻阴。梨花欲谢恐难禁。 这是她内心的苦闷与骚动。（爱情这位不速之客终于叩启了她的心扉，撩拨着这颗多情易感的芳心，“醒时空对烛花红”当是她春情萌动的伊始。） 红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。 这是她倾诉愁肠，思恋负笈远游的丈夫的闺怨。同样的情境的还有： 薄雾浓云愁永昼，瑞脑销金兽。佳节又重阳，玉枕纱厨，半夜凉初透。东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。 最后三句“莫道不销魂，帘卷西风，人比黄花瘦”，可谓万斛愁情。 寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急？雁过也，正伤心，却是旧时相识。满地黄花堆积。憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑？梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！ 这是她晚年的凄清孤寂。白铸清词，骚坛独步，这就是她的成就现实中爱的匮乏与破灭，悲凉之雾广被华林，恰好为她的艺术创造提供了源源不竭的灵泉。或许，她的端庄典雅、凄清之美，她那灵明的心性会同她的词句一起终古滋润着浊世人群的心田。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js几种事件处理程序]]></title>
      <url>%2F2016%2F04%2F15%2Fjs%20%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[js几种事件处理程序 微信公众号阅读 事件就是用户或浏览器自身执行的某种动作，如click,laod,mouseover都是事件的名称。 事件流描述的是从页面中接收事件的顺序。 事件处理程序就是对事件作出响应的函数。事件处理程序的名字以“on”开头，如click事件对应的事件处理程序的名称为onclick。 为事件指定处理程序的方式有多种，如：HTML事件处理程序、DMO0级事件处理程序、DOM2级事件处理程序、IE事件处理程序、跨浏览器事件处理程序。 （1）html事件处理程序 即：将事件处理程序，写在相应的html标签中。eg: 1&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;alert(&quot;hello&quot;)&quot; /&gt; 缺点：①存在一个时间差，当用户在html元素一出现在页面上就去触发相应的事件时，事件的处理程序可能还不具备执行条件（比如说调用的函数还木有被解析），就会引发错误。eg: 12&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;message()&quot; /&gt;&lt;script type=&quot;text/JavaScript&quot;&gt; function message(){ alert(&quot;hello world&quot;); } 因为调用的函数处于按钮的下方，如果在message函数被加载之前就点击了按钮就会引发错误。②html和js代码耦合度太高，如果要改变事件处理程序，就要改动两个地方：html代码和javascript代码。 （2）DMO0级事件处理程序eg: 1234var btn=document.getElementById(&quot;myBtn&quot;); btn.onclick=function()&#123; alert(this.id)&#125;; 注意：如果这段代码位于按钮之后，就有可能在一点时间内怎么点击都木有反应，因为在这段代码运行以前不会指定事件处理程序。 DMO0级事件处理程序被认为是元素的方法，换句话说，DMO0级事件处理程序是在元素的作用域中运行的，所以程序中的this引用当前元素。可以在事件处理程序中通过this访问元素的任何属性和方法。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 也可删除指定的事件处理程序，只要将事件处理程序的属性设置为null就Ok了。eg: 1btn.onclick=null; 将处理程序设置为null以后，再点击按钮不会发生任何动作。 （3）DOM2级事件处理程序 DOM2级事件定义了两个方法，用于指定和删除事件处理程序。这两个操作分别为：addEventListener()和removeEventListner().所有的DOM节点都包含这两个方法。他们要接受3个参数，分别为：要处理的事件名，处理函数，布尔值。最后的布尔值参数如果为ture,表示在捕获阶段处理程序，如果为false，表示在冒泡阶段调用事件处理程序。 例如在按钮上为click添加事件处理程序，可以用下面的代码： 12345var btn=document.getElementById(&quot;myBtn&quot;);btn.addEventListner(&quot;onclick&quot;,function()&#123;alert(&quot;hello world&quot;);false&#125;);//这里添加的事件处理程序也是依附于元素的的作用域 使用DOM2事件处理程序的优点是：可以为同一个元素添加多个事件处理程序。例： 123var btn=getElementById(&quot;myBtn&quot;); btn.addEventListner(&quot;click&quot;,function()&#123;alert(this.id);&#125;,flase); btn.addEventListner(&quot;click&quot;,function()&#123;alert(&quot;hello world&quot;);&#125;,flase); 结果：先显示id，后显示hello world。通过addEventListner()添加的事件处理程序只能通过removeEventListner来删除。移除时使用的参数与添加事件处理程序的参数相同。另：通过addEventListner添加的匿名函数无法删除。 （4）IE事件处理程序。 IE添加和删除事件处理程序的函数分别为：attachEvent()和detachEvent();这两个函数接收相同的两个参数：事件处理程序名与事件处理函数。由于IE只支持事件冒泡，所以通过attachEvent添加的事件处理程序都会添加到冒泡阶段。例如： 12var btn=document.getElementById(&quot;myBtn&quot;);btn.attachEvent(&quot;onclick&quot;,function()&#123;alert(&quot;hello world&quot;);&#125;); IE在使用attachEvent方法的情况下，事件处理程序的作用域为全局作用域，因此this等于window。（在编写跨浏览器的代码时，记住这一点非常重要）。与addEventListner类似，attachEvent()方法也可以用来为一个元素添加多个事件处理程序；eg: 123var btn=document.getElementById(&quot;myBtn&quot;);btn.attachEvent(&quot;onclick&quot;,function()&#123;alert(&quot;clicked&quot;);&#125;);btn.attachEvent(&quot;onclick&quot;,function()&#123;alert(&quot;hello world&quot;);&#125;); 值得注意的是：这些事件的处理程序是按逆序触发的，也就是说，先弹出hello world 再弹出clicked。detach()使用方法略。 （5）跨浏览器的事件处理程序 为了以跨浏览器的方式处理事件，主要可以使用两个方法：①使用能隔离浏览器差异的js库。②自己编写最适合的事件处理方法。这里要用到能力检测，即：识别浏览器的能力。要保证代码能在大多数浏览器下一致的运行，只须关注冒泡阶段。 代码步骤如下： 首先要创建的方法是addHandler(用于处理跨浏览器的兼容性问题，这里没有给出具体代码),它的职责是视情况判定使用DOM0级方法，DOM2级方法，IE方法来添加事件。addHandler接收3个参数：要操作的元素、事件名称、事件处理程序函数。这个方法属于一个名叫EventUtil的对象。这里使用这个对象来处理浏览器之间的差异。与addHandler对应的方法是removeHandler(),它也接受相同的参数。这个事件的职责是移除之前添加的事件处理程序。不论事件是以什么方式添加到对象中的，如果其他方法程序无效，则默认使用DOM0级方法。使用EventUtil的方法如下： 1234567var btn=document.getElementById(&quot;myBtn&quot;);var handler=function()&#123;alert(&quot;hello&quot;)&#125;;//事件处理程序EventUtil.addHandler(btn,&quot;onclick&quot;,handler);//其他代码EventUtil.removeHandler(btn,&quot;onclick&quot;,handler);addHandler()和removeHandler() 没有考虑到所有的浏览器问题，例如IE中作用域的问题，但是使用它们添加和移除事件处理程序还是足够了。 参考： 《javascript高级程序设计》13章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js实现放大镜特效]]></title>
      <url>%2F2016%2F03%2F30%2Fjs%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%A4%A7%E9%95%9C%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[js实现放大镜特效 效果 实现原理： 鼠标在小图片上移动时，通过捕获鼠标在小图片上的位置，定位大图片的相应位置 技术点 事件捕获 onmouseover onmouseout onmousemove 定位 offsetLeft offsetTop offsetWidth offsetHeight event.clientX event.clientY 计算 浏览器兼容性 问号部分即：objBigBoxImage.style.left很容易求出 同理可以求出objBigBoxImage.style.top 源码github clone地址:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;放大镜&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; #demo &#123; display: block; width: 400px; height: 255px; margin: 50px; position: relative; border: 1px solid #ccc; &#125; #small-box &#123; position: relative; z-index: 1; &#125; #float-box &#123; display: none; width: 160px; height: 120px; position: absolute; background: #ffffcc; border: 1px solid #ccc; filter: alpha(opacity=50); opacity: 0.5; &#125; #mark &#123; position: absolute; display: block; width: 400px; height: 255px; background-color: #fff; filter: alpha(opacity=0); opacity: 0; z-index: 10; &#125; #big-box &#123; display: none; position: absolute; top: 0; left: 460px; width: 400px; height: 300px; overflow: hidden; border: 1px solid #ccc; z-index: 1;; &#125; #big-box img &#123; position: absolute; z-index: 5 &#125; &lt;/style&gt; &lt;script&gt; //页面加载完毕后执行 window.onload = function () &#123; var objDemo = document.getElementById(&quot;demo&quot;); var objSmallBox = document.getElementById(&quot;small-box&quot;); var objMark = document.getElementById(&quot;mark&quot;); var objFloatBox = document.getElementById(&quot;float-box&quot;); var objBigBox = document.getElementById(&quot;big-box&quot;); var objBigBoxImage = objBigBox.getElementsByTagName(&quot;img&quot;)[0]; objMark.onmouseover = function () &#123; objFloatBox.style.display = &quot;block&quot; objBigBox.style.display = &quot;block&quot; &#125; objMark.onmouseout = function () &#123; objFloatBox.style.display = &quot;none&quot; objBigBox.style.display = &quot;none&quot; &#125; objMark.onmousemove = function (ev) &#123; var _event = ev || window.event; //兼容多个浏览器的event参数模式 var left = _event.clientX - objDemo.offsetLeft - objSmallBox.offsetLeft - objFloatBox.offsetWidth / 2; var top = _event.clientY - objDemo.offsetTop - objSmallBox.offsetTop - objFloatBox.offsetHeight / 2; if (left &lt; 0) &#123; left = 0; &#125; else if (left &gt; (objMark.offsetWidth - objFloatBox.offsetWidth)) &#123; left = objMark.offsetWidth - objFloatBox.offsetWidth; &#125; if (top &lt; 0) &#123; top = 0; &#125; else if (top &gt; (objMark.offsetHeight - objFloatBox.offsetHeight)) &#123; top = objMark.offsetHeight - objFloatBox.offsetHeight; &#125; objFloatBox.style.left = left + &quot;px&quot;; //oSmall.offsetLeft的值是相对什么而言 objFloatBox.style.top = top + &quot;px&quot;; var percentX = left / (objMark.offsetWidth - objFloatBox.offsetWidth); var percentY = top / (objMark.offsetHeight - objFloatBox.offsetHeight); objBigBoxImage.style.left = -percentX * (objBigBoxImage.offsetWidth - objBigBox.offsetWidth) + &quot;px&quot;; objBigBoxImage.style.top = -percentY * (objBigBoxImage.offsetHeight - objBigBox.offsetHeight) + &quot;px&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt; &lt;div id=&quot;small-box&quot;&gt; &lt;div id=&quot;mark&quot;&gt;&lt;/div&gt; &lt;div id=&quot;float-box&quot;&gt;&lt;/div&gt; &lt;img src=&quot;image/macbook-small.jpg&quot;/&gt; &lt;/div&gt; &lt;div id=&quot;big-box&quot;&gt; &lt;img src=&quot;image/macbook-big.jpg&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 解决兼容性问题测试工具：IETester详情讲解 主要思路：加一个遮罩层 另附jQuery实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;放大镜&lt;/title&gt;&lt;script src=&quot;http://libs.baidu.com/jquery/1.10.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123;margin: 0;padding: 0&#125;#demo &#123;display: block;width: 400px;height: 255px;margin: 50px;position: relative;border: 1px solid #ccc;&#125;#small-box &#123;position: relative;z-index: 1;&#125;#float-box &#123;display: none;width: 160px;height: 120px;position: absolute;background: #ffffcc;border: 1px solid #ccc;filter: alpha(opacity=50);opacity: 0.5;cursor: move;&#125;#mark &#123;position: absolute;display: block;width: 400px;height: 255px;z-index: 10;background: #fff;filter: alpha(opacity=0);opacity: 0;cursor: move;&#125;#big-box &#123;display: none;position: absolute;top: 0;left: 460px;width: 400px;height: 300px;overflow: hidden;border: 1px solid #ccc;z-index: 1;;&#125;#big-box img &#123;position: absolute;z-index: 5&#125;&lt;/style&gt;&lt;script&gt; $(function()&#123; var markWidth = $(&apos;#mark&apos;).width(), markHeight = $(&apos;#mark&apos;).height(), floatBoxWidth = $(&apos;#float-box&apos;).width(), floatBoxHeight = $(&apos;#float-box&apos;).height(), percent = $(&apos;#big-box&apos;).width() / $(&apos;#float-box&apos;).width() $(&apos;#mark&apos;).on(&apos;mouseover&apos;, function()&#123; $(&apos;#float-box&apos;).show() $(&apos;#big-box&apos;).show() &#125;).on(&apos;mouseout&apos;, function()&#123; $(&apos;#float-box&apos;).hide() $(&apos;#big-box&apos;).hide() &#125;).on(&apos;mousemove&apos;, function(e)&#123; e = e || window.event var markOffset = $(&apos;#mark&apos;).offset() var left = e.clientX - markOffset.left - floatBoxWidth / 2, top = e.clientY - markOffset.top - floatBoxHeight / 2 if(left &lt; 0) left =0 else if(left &gt; markWidth - floatBoxWidth) left = markWidth - floatBoxWidth if(top &lt; 0) top =0 else if(top &gt; markHeight - floatBoxHeight) top = markHeight - floatBoxHeight $(&apos;#float-box&apos;).css(&#123;left: left+&apos;px&apos;, top: top+&apos;px&apos;&#125;) $(&apos;#big-box&gt;img&apos;).css(&#123;left: -left*percent+&apos;px&apos;, top: -top*percent+&apos;px&apos;&#125;) &#125;) &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt;&lt;div id=&quot;small-box&quot;&gt;&lt;div id=&quot;mark&quot;&gt;&lt;/div&gt;&lt;div id=&quot;float-box&quot;&gt;&lt;/div&gt;&lt;img src=&quot;image/macbook-small.jpg&quot;/&gt;&lt;/div&gt;&lt;div id=&quot;big-box&quot;&gt;&lt;img src=&quot;image/macbook-big.jpg&quot;/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考： 慕课网 用JS实现放大镜特效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python中的布尔类型运算]]></title>
      <url>%2F2016%2F03%2F25%2FPython%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%2F</url>
      <content type="text"><![CDATA[python中的布尔类型运算 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 12a = Trueprint a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js闭包]]></title>
      <url>%2F2016%2F03%2F07%2Fjs%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[js闭包 闭包（1）概念闭包是指有权访问另一个函数作用域中的变量的函数。（2）特性闭包只能取得包含函数中任何变量的最后一个值。（3）创建方式在一个函数内部创建另一个函数。（4）原理在一个函数内部中定义的函数会将包含函数（外部函数）的活动对象添加到其作用域中，直至解除对内部函数的应用，内部函数被销毁，外部函数的活动对象才会被销毁。（5）实例 12345678910111213141516function closure()&#123; var result=[]; for (var i = 0; i &lt; 4; i++) &#123; result[i]=function()&#123; console.log(i); return i; &#125; &#125;; return result;&#125;var result=closure();for (var i = 0; i &lt; 4; i++) &#123; result[i]();&#125;;//4 4 4 4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS实现简单图片展示]]></title>
      <url>%2F2016%2F03%2F07%2Fcss%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[CSS实现简单图片展示 效果： css部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 div,ul,li,dl,dt,dd&#123; margin:0; padding:0;&#125;ul,li,dl,dt,dd&#123; list-style:none;&#125;.demo&#123; margin:0 auto; width:930px;&#125;.demo ul li&#123; float:left; width:300px; margin-right:6px; position:relative;&#125;.demo ul li img&#123; border:none; position:relative; z-index:22;&#125;.demo ul li a&#123; width:300px; display:block; border:2px solid #ccc;&#125;.demo ul li a:hover&#123; border:2px solid #C03;&#125;.demo ul li a span&#123; position:absolute; z-index:33; bottom:2px; left:2px; width:300px; height:40px; filter:alpha(Opacity=50); -moz-opacity:0.5; opacity: 0.5; background:#000; color:#fff; line-height:40px; text-align:left; display:none;&#125;.demo ul li a:hover span&#123; display:block;&#125; html部分 &lt;div class=&quot;demo&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a&gt; &lt;img src=&quot;1.jpg&quot; /&gt; &lt;span&gt;keep moving&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt; &lt;img src=&quot;2.jpg&quot; /&gt; &lt;span&gt;stay hungry &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt; &lt;img src=&quot;3.jpg&quot; /&gt; &lt;span&gt;stay foolish&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 参考慕课网 图片展示特效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas之arcTo]]></title>
      <url>%2F2016%2F02%2F21%2Fcanvas%E4%B9%8BarcTo%2F</url>
      <content type="text"><![CDATA[canvas之arcTo canvas提供画圆弧有两种方法，一个是arc，另一个就是arcTo，arc挺简单的，这里就不再说了，单说一下arcTo。arcTo的作用是绘制介于两条切线之间的弧，语法是arcTo（x1,y1,x2,y2,r）,其中x1，y1是起始点的坐标，x2，y2是终点的坐标，r则是圆弧的半径。这里面有个很大的误区，一般的初学者看到这里，都会错误的判断起始点的位置，如图1所示： 正确的理解应如图2所示，起始点位于两条切线相交的位置，另外，终点也并不是弧的终点，而是另一条切线上的任意一点，拿图2来说，终点是竖直的那条切线上的一点。有人会问，可不可以在起始点的上面那里，因为切线是直线，可以延伸的。答案是当然可以，但这样的结果是圆弧就会向上弯曲，而不是向下弯曲了。按我的理解，可以总结为，起始点控制前半段弧的方向，终点控制后半段弧的方向，至于r嘛，控制弧的大小。 下面一个简单的动画帮助理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style&gt; canvas &#123; width: 400px; height: 400px; background-color: #EEEEEE; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var canvas = document.getElementById(&apos;canvas&apos;); var arcToPoint1 = &#123;x:120, y:40&#125;; var arcToPoint2 = &#123;x:60, y:80&#125; var context = canvas.getContext(&apos;2d&apos;); if (!canvas || !canvas.getContext) &#123; return; &#125; else &#123; timer = setInterval(function()&#123; if (arcToPoint2.x &lt; 150) &#123; arcTo (context, arcToPoint1, arcToPoint2); arcToPoint2.x += 2; &#125; else &#123; clearInterval(timer); &#125; &#125;, 300); &#125; &#125; function arcTo () &#123; var startPoint = &#123;x: 20, y: 40&#125;; var context = arguments[0]; var arcToPoint1 = arguments[1]; var arcToPoint2 = arguments[2]; var context = canvas.getContext(&apos;2d&apos;); context.clearRect(0,0,context.canvas.width, context.canvas.height) context.beginPath(); context.moveTo(startPoint.x, startPoint.y); context.strokeStyle = &quot;red&quot;; context.lineWidth = 1; context.arcTo(arcToPoint1.x, arcToPoint1.y, arcToPoint2.x, arcToPoint2.y, 40); context.stroke(); context.beginPath(); context.moveTo(startPoint.x, startPoint.y); context.strokeStyle = &quot;black&quot;; context.lineWidth = 1; context.lineTo(arcToPoint1.x, arcToPoint1.y); context.fillText(&apos;arcToPoint1&apos;, arcToPoint1.x + 10, arcToPoint1.y - 5) context.stroke(); context.beginPath(); context.moveTo(arcToPoint1.x, arcToPoint1.y); context.strokeStyle = &quot;black&quot;; context.lineWidth = 1; context.lineTo(arcToPoint2.x, arcToPoint2.y); context.fillText(&apos;arcToPoint2&apos;, arcToPoint2.x + 10, arcToPoint2.y + 10) context.stroke(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt; 此游览器不支持canvas标签 &lt;/canvas&gt; &lt;/body&gt; &lt;/html&gt; 参考HTML5 canvas arcTo() 方法Canavs arcTo方法的理解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas绘制移动端写字面板]]></title>
      <url>%2F2016%2F02%2F10%2FHTML5web%E5%B0%8F%E5%BA%94%E7%94%A8%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%86%99%E5%AD%97%E9%9D%A2%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[canvas绘制移动端写字面板 GitHub：https://github.com/AlexZ33/canvas_demo演示链接 主要知识点 鼠标事件响应 屏幕坐标canvas坐标转换 Viewpoint 屏幕自适应（jquery实现） 屏幕触控响应事件（touch） 参考：慕课网 学写一个字HTML meta viewport属性说明(mark)移动端touch事件和click事件的区别jQuery Mobile Touch 事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas绘制闪烁星星效果]]></title>
      <url>%2F2016%2F01%2F25%2FCanvas%E7%BB%98%E5%88%B6%E9%97%AA%E7%83%81%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
      <content type="text"><![CDATA[canvas绘制闪烁星星效果 GitHub：https://github.com/AlexZ33/canvas_demo/tree/gh-pages演示链接 主要知识点 如何轮播序列帧 canvas API drawImage(); globalAlpha; Save; Restore 如何添加鼠标事件 循环调用 Window API -requestAnimFrame(function(){}); -setTimeout(function(){},time); -setInterval(function(){},time); 三者的区别 总体思路 搭建网页结构 绘制背景 绘制女孩图片 鼠标点画圆闪烁变动，以及连线其他原点 requestAnimationFrame 更新画面 参考：慕课网 canvas实现星星闪烁特效GameLoop的几种实现方式Javascript中的setTimeout,setInterval,requestAnimFrame[Request Animation Frame for Better Performance]https://software.intel.com/en-us/html5/hub/blogs/request-animation-frame-for-better-performance/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas背景动画（仿知乎登录页面动画）]]></title>
      <url>%2F2016%2F01%2F17%2Fcanvas%E4%BB%BF%E7%9F%A5%E4%B9%8E%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[canvas背景动画（仿知乎登录页面动画） 演示链接 主要知识点 canvas画图 es6 class 语法应用 总体思路 创建 canvas 对象 canvas 画圆和画直线 圆圈移动 鼠标点画圆闪烁变动，以及连线其他原点 requestAnimationFrame 更新画面 参考：requestAnimationFrameECMAScript 6 入门 Class初学canvas仿知乎登录页面动画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas 绘制时钟]]></title>
      <url>%2F2016%2F01%2F12%2FCanva%E7%BB%98%E5%88%B6%E6%97%B6%E9%92%9F%2F</url>
      <content type="text"><![CDATA[Canvas 绘制时钟演示链接 主要知识点 canvas画图 rotate(),lineCap(),save(),store()等api 总体思路和教程慕课网 Canvas 绘制时钟]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3实现三角形和气泡效果]]></title>
      <url>%2F2016%2F01%2F07%2FCSS3%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E5%92%8C%E6%B0%94%E6%B3%A1%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[三角形的实现 html结构123&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; css样式12345678 div&#123; height: 0; width: 0; border-top: 40px solid #000; border-right: 40px solid #ff0000; border-left: 40px solid #ff0000; border-bottom: 40px solid #000;&#125; 显示效果用css画三角形很简单，就是将一个块元素宽高设置为0，然后给某一边设一个比较厚的宽度利用盒子的均分原理，盒子都是矩形或者正方形，从形状的中心，向4个上下左右划分4个部分。保证元素是块级元素，设置元素的边框，不需要显示的边框使用透明色transparent。 所以，如果你要一个向上或者向下的三角:border-left和border-right就是transparent，而border-bottom可见则三角向上，border-top可见则三角向下12345678 div&#123; height: 0; width: 0; border-top: 40px solid transparent; border-right: 40px solid transparent; border-left: 40px solid transparent; border-bottom: 40px solid #000;&#125; 如果你要一个向左或者向右的三角:border-top和border-bottom就是transparent，而设置border-left则三角向右，设置border-right则三角向左12345678 div&#123; height: 0; width: 0; border-top: 40px solid transparent; border-right: 40px solid transparent; border-left: 40px solid #000; border-bottom: 40px solid transparent;&#125; 如果它的上是有的，但是右是透明的，就会是下面的效果border-top: 100px solid red;border-right: 100px solid transparent; 1234567 div&#123; height: 0; width: 0; border-top: 40px solid #000; border-right: 40px solid transparent; &#125; 当然还有这样的：123456789 div&#123; height: 0; width: 0; border-top: 40px solid #000; border-right: 30px solid #ff0000; border-left: 50px solid #ff0000; border-bottom: 25px solid #000; &#125; 很明显的左三角和下三角的比例是2:1，在下三角可以明显的看出来，下三角的底边，左右2:1；同理，根据上面的上下左右布局，应该没有什么三角是画不出来的 示例 如下图的时光轴旁边的小三角 就可以用以上的方法实现12345678910 .content_item_icon_arrow&#123; position: absolute; left: -10px; top: 20px; height: 0px; border-color:transparent #e2e2e2 transparent transparent; border-width: 10px 10px 10px 0px; border-style: dashed solid dashed dashed;&#125; 气泡效果实现 以前我们要实现对话气泡效果很麻烦，基本上是用切图的方法。现在有了CSS3就变得简单多了。一个HTML元素，一些CSS3代码，不需要图片，也不需要JavaScript。如下图： 12345678910111213141516171819202122232425262728293031 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt; css3实现气泡&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px;height: 100px; border: 5px solid #eee;margin-left: 10px;position: relative; &#125; .box .arrow&#123; position: absolute;top: 100px;left: 30px;width: 50px;height: 50px; &#125; .a1&#123; border: 30px solid #f00;display: block;border-color: #eee transparent transparent transparent; &#125; .a2&#123;position: absolute;left: 0;top: -8px;border: 30px solid #f00;display: block;border-color: #fff transparent transparent transparent &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="arrow"&gt; &lt;span class="a1"&gt;&lt;/span&gt; &lt;span class="a2"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt; css3实现气泡 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style type="text/css"&gt;#demo&#123; position: relative; width: 200px; height: 100px; background-color: #fff; border: 8px solid #666; -webkit-border-radius: 30px; -moz-border-radius: 30px; border-radius: 30px; -webkit-box-shadow: 2px 2px 4px #888; -moz-box-shadow: 2px 2px 4px #888; box-shadow: 2px 2px 4px #888;&#125;#demo:before&#123; content: ' '; position: absolute; width: 0; height: 0; left: 30px; top: 100px; border: 25px solid; border-color: #666 transparent transparent #666;&#125;#demo:after&#123; content: ' '; position: absolute; width: 0; height: 0; left: 38px; top: 100px; border: 15px solid; border-color: #fff transparent transparent #fff;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 参考：CSS3实现气泡效果CSS3 巧妙实现聊天气泡CSS3 聊天气泡框以及 inherit、currentColor 关键字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 各目录的作用]]></title>
      <url>%2F2015%2F12%2F30%2FLinux%E5%90%84%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
      <content type="text"><![CDATA[/根目录 /bin bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着使用者最经常使用的命令。例如cp、ls、cat，等等。命令保存目录（普通用户就可以读取的命令） 根目录下的bin和sbin，usr目录下的bin和sbin，这四个目录都是用来保存系统命令的。 其中，bin目录下的命令任何用户都可以执行，sbin目录下只有root才可以执行。 linux使用此方式来区分用户权限。 /boot启动目录，启动相关文件，这里存放的是启动Linux时使用的一些核心文件。 /dev设备文件保存目录dev是device（设备）的缩写。这个目录下是所有Linux的外部设备，其功能类似DOS下的.sys和Win下的.vxd。在Linux中设备和文件是用同种方法访问的。例如：/dev/hda代表第一个物理IDE硬盘。/etc配置文件保存目录这个目录用来存放系统管理所需要的配置文件和子目录。/home普通用户的家目录用户的主目录，比如说有个用户叫zk，那他的主目录就是/home/zk也可以用~zk表示。 /lib系统库保存目录这个目录里存放着系统最基本的动态链接共享库，其作用类似于Windows里的.dll文件。几乎所有的应用程序都须要用到这些共享库。 /mnt系统挂载目录这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。/media挂载目录 /root超级用户的家目录系统管理员（也叫超级用户）的主目录。作为系统的拥有者，总要有些特权啊！比如单独拥有一个目录。 /tmp临时目录这个目录不用说，一定是用来存放一些临时文件的地方了。 /sbin命令保存目录（超级用户才能使用的目录）s就是Super User的意思，也就是说这里存放的是系统管理员使用的管理程序。 /proc直接写入内存（是内存中有关系统进程的实时信息）这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。 /sys直接写入内存（是有关系统内核以及驱动的实时信息）这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log目录中。 porc同sys目录不能直接操作，这两个目录保存的是内存的挂载点。 其中的数据直接写在内存中。避免数据丢失或由于内存溢出导致系统崩溃。 /usr系统软件资源目录这是最庞大的目录，我们要用到的应用程序和文件几乎都存放在这个目录下。其中包含以下子目录： /usr/bin存放着许多应用程序；系统命令（普通用户） /usr/sbin给超级用户使用的一些管理程序就放在这里；系统命令（超级用户） /usr/includeLinux下开发和编译应用程序需要的头文件，在这里查找； /usr/lib存放一些常用的动态链接共享库和静态档案库； /usr/local这是提供给一般用户的/usr目录，在这里安装软件最适合； /usr/srcLinux开放的源代码就存在这个目录，爱好者们别放过哦！ /var系统相关文档内容这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log目录中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书笔记 | 如何读历史？]]></title>
      <url>%2F2015%2F12%2F30%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E5%8E%86%E5%8F%B2%2F</url>
      <content type="text"><![CDATA[如何阅读历史 一切历史都是当代史 历史更偏向于故事，而不是科学。对于历史不那么感兴趣的人可能认为，历史书是一种客观严肃的读物，事实上就像广泛流传的那句话一样：历史是由胜利者书写的，历史是任人打扮的小姑娘–《如何阅读一本书》房龙的宽容：这样的事情发生在过去，也发生在现在不过将来，我们希望，这样的事情不再发生了。 托尔斯泰认为，造成人类行为的原因太多，又太复杂，而且动机又深深隐藏在潜意识里，因此我们无法知道为什么会发生某些事。 亚里士多德说：“诗比历史更有哲学性。”他的意思是诗更具一般性，更有普遍影响力。一首好诗不只在当时当地是一首好诗，也在任何时间任何地点都是好诗。这样的诗对所有人类来说都有意义与力量。历史不像诗那样有普遍性。历史与事件有关，诗却不必如此。但是一本好的历史书仍然是有普遍性的。修昔底德说过，他写历史的原因是：希望经由他所观察到的错误，以及他个人受到的灾难与国家所受到的苦楚，将来的人们不会重蹈覆辙。他所描述的人们犯下的错误，不只对他个人或希腊有意义，对整个人类来说更有意义。在二千五百年以前，雅典人与斯巴达人所犯的错误，今天人们仍然同样在犯—或至少是非常接近的错误—修昔底德以降，这样的戏码一再上演。 总之，阅读历史的两个要点是：第一，对你感兴趣的事件或时期，尽可能阅读一种以上的历史书。第二，阅读历史时，不只要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。 阅读历史书要提出的问题：尽管历史书更接近小说，而非科学，但仍然能像阅读论说性作品一样来阅读，也应该如此阅读。因此，在阅读历史时，我们也要像阅读论说性作品一样，提出基本的问题。因为历史的特性，我们要提出的问题有点不同，所期待的答案也稍微不同。每一本历史书都有一个特殊而且有限定范围的主题。因此，如果我们要把历史读好，我们就要弄清楚这本书在谈什么，没有谈到的又是什么。当然，如果我们要批评这本书，我们一定要知道它没谈到的是什么。一位作者不该因为他没有做到他根本就没想做的事情而受到指责。我们一定要知道这位作者是用什么方法来说故事的。他将整本书依照年代、时期或世代区分为不同的章节？还是按照其他的规则定出章节？他是不是在这一章中谈那个时期的经济历史，而在别章中谈战争、宗教运动与文学作品的产生？其中哪一个对他来说最重要？如果我们能找出这些，如果我们能从他的故事章节中发现他最重视的部分，我们就能更了解他。我们可能不同意他对这件事的观点，但我们仍然能从他身上学到东西。 批评历史常有的两种方式：在我们读完并完全了解书中的意义之后批评。如批评 书不够逼真 误解了史实 判断失真 无法掌握任性 对老一辈史书缺少经济事务的批评 对那些高大形象 描述的大公无私高贵情操人物的怀疑 一个好的历史学家要能兼具说故事的人与科学家的能力。他必须像某些目击者或作家说一些事情确实发生过一样，知道一些事情就是可能发生过。即：能够消除读者的疑虑（某方面某领域有研究的人）会认为作者误用了资料 或者作者自己的判断就是错的。我们希望历史学家具备完备的知识。 历史与我何干？这个世界已经变得很渺小又危机四伏，每个人都该开始把历史读好才行。一切历史都是当代史。 ·END·]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题汇总]]></title>
      <url>%2F2015%2F12%2F30%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[前端面试题汇总 罗列一些面试常见问题前端面试（一）前端面试（二）前端面试（三）前端面试（四） ·END·]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2014%2F05%2F07%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[这是新的开始，我用hexo创建了第一篇文章。]]></content>
    </entry>

    
  
  
</search>
